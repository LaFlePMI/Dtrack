The code you showed is correct as-is (from your previous message), but to make the toggleMode update for routing work, replace the entire floating buttons script block (the one with (function(){ ... })();) with this updated version. This keeps the original floating button logic and adds the routing visibility/sync/render.
Here's the replacement (copy-paste it directly over the old one):
HTML<script>
// Ensure we have a ClarityApp instance (in case something loaded out of order)
if (!(window.app instanceof ClarityApp)) {
  window.app = new ClarityApp();
}

// If this build doesn't have updateTask, define it now (permanent fix you wanted)
if (typeof ClarityApp?.prototype?.updateTask !== 'function') {
  ClarityApp.prototype.updateTask = function (id, changes) {
    this.historyManager.push();
    const task = this.state.tasks.find(t => t.id === id);
    if (!task) { console.warn('Task not found for update:', id); return; }
    Object.assign(task, changes);
    this.saveState();     // debounced in your newer version, otherwise fine
    this.renderBoard();
    this.showToast('Task updated');
  };
  console.log('✔ updateTask was missing — FIXED');
}

// Optional: guard against later overwrites of window.app
try { Object.defineProperty(window, 'app', { writable: false, configurable: false }); } catch {}

// Diagnostic: check in Console after reload
console.log('[clarity check]', window.app?.constructor?.name, 'updateTask =', typeof window.app?.updateTask);

// Wire floating buttons: visibility + click handlers (UPDATED with routing toggle)
(function(){
  const container = document.getElementById('floating-rt-actions');
  const btnNew = document.getElementById('floating-new-nc');
  const btnReports = document.getElementById('floating-view-reports');

  function updateVisibility(){
    // Show only when defect tracker mode is active
    try {
      if (window.app && window.app.state && window.app.state.mode === 'defects') {
        container.classList.remove('hidden');
        container.setAttribute('aria-hidden','false');
      } else {
        container.classList.add('hidden');
        container.setAttribute('aria-hidden','true');
      }
    } catch(e) { /* safe-fail */ }
  }

  // Click handlers
  if (btnNew) btnNew.onclick = () => { try { window.app.defectTracker.prepareAddNC(); } catch(e){console.error(e);} };
  if (btnReports) btnReports.onclick = () => { try { window.app.defectTracker.openReportsModal(); } catch(e){console.error(e);} };

  // Polling fallback: update visibility periodically and on toggle
  updateVisibility();
  const iv = setInterval(updateVisibility, 700);

  // Also update when app.toggleMode exists (wrap it if present) — UPDATED with routing
  if (window.app && typeof window.app.toggleMode === 'function') {
    const orig = window.app.toggleMode.bind(window.app);
    window.app.toggleMode = function(newMode) {
      const res = orig(newMode);
      
      // Add routing visibility
      document.getElementById('board-canvas').style.display = newMode === 'kanban' ? 'grid' : 'none';
      document.getElementById('defect-tracker-view').style.display = newMode === 'defects' ? 'block' : 'none';
      document.getElementById('routing-view').style.display = newMode === 'routing' ? 'block' : 'none';
      
      // Sync state
      app.state.mode = newMode;
      app.saveState();
      
      // Initial render for routing
      if (newMode === 'routing' && app.routing) {
        app.routing.renderTable();
      }
      
      // Existing floating visibility update
      setTimeout(updateVisibility, 60);
      
      return res;
    };
  }

  // Cleanup when page unloads
  window.addEventListener('beforeunload', ()=> clearInterval(iv));
})();
</script>
